#!/usr/bin/env node
var path = require('path');
var arg = require('arg');
require('fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var arg__default = /*#__PURE__*/_interopDefaultLegacy(arg);

function exit(err) {
    logger.error(err);
    process.exit(1);
}
var formatDuration = function(duration) {
    return duration >= 1000 ? "" + duration / 1000 + "s" : "" + duration + "ms";
};
var logger = {
    log: function log(arg) {
        console.log(arg);
    },
    warn: function warn(arg) {
        console.log("\x1b[33m" + arg + "\x1b[0m");
    },
    error: function error(arg) {
        console.error("\x1b[31m" + arg + "\x1b[0m");
    }
};

var version = "2.1.6";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var helpMessage = "\nUsage: bunchee [options]\n\nOptions:\n  -v, --version          output the version number\n  -w, --watch            watch src files changes\n  -m, --minify           compress output. default: false\n  -o, --output <file>    specify output filename\n  -f, --format <format>  type of output (esm, amd, cjs, iife, umd, system), default: esm\n  -e, --external <mod>   specify an external dependency\n  -h, --help             output usage information\n  --target <target>      js features target: swc target es versions. default: es5\n  --runtime <runtime>    build runtime (nodejs, browser). default: browser\n  --cwd <cwd>            specify current working directory\n  --sourcemap            enable sourcemap generation, default: false\n  --dts                  determine if need to generate types, default: false\n";
function help() {
    logger.log(helpMessage);
}
function parseCliArgs(argv) {
    var args;
    args = arg__default["default"]({
        "--cwd": String,
        "--dts": Boolean,
        "--output": String,
        "--format": String,
        "--watch": Boolean,
        "--minify": Boolean,
        "--help": Boolean,
        "--version": Boolean,
        "--runtime": String,
        "--target": String,
        "--sourcemap": Boolean,
        "--external": [
            String
        ],
        "-h": "--help",
        "-v": "--version",
        "-w": "--watch",
        "-o": "--output",
        "-f": "--format",
        "-m": "--minify",
        "-e": "--external"
    }, {
        permissive: true,
        argv: argv
    });
    var source = args._[0];
    var parsedArgs = {
        source: source,
        format: args["--format"],
        file: args["--output"],
        watch: args["--watch"],
        minify: args["--minify"],
        sourcemap: !!args["--sourcemap"],
        cwd: args["--cwd"],
        dts: args["--dts"],
        help: args["--help"],
        version: args["--version"],
        runtime: args["--runtime"],
        target: args["--target"],
        external: args["--external"]
    };
    return parsedArgs;
}
function run(args) {
    return _run.apply(this, arguments);
}
function _run() {
    _run = _asyncToGenerator(function(args) {
        var source, format, watch, minify, sourcemap, target, runtime, dts, cwd, file, cliArgs, entry, bundle, timeStart, timeEnd, err, duration;
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    source = args.source, format = args.format, watch = args.watch, minify = args.minify, sourcemap = args.sourcemap, target = args.target, runtime = args.runtime, dts = args.dts;
                    cwd = args.cwd || process.cwd();
                    file = args.file ? path__default["default"].resolve(cwd, args.file) : undefined;
                    cliArgs = {
                        dts: dts,
                        file: file,
                        format: format,
                        cwd: cwd,
                        target: target,
                        runtime: runtime,
                        external: args.external || [],
                        watch: !!watch,
                        minify: !!minify,
                        sourcemap: sourcemap === false ? false : true
                    };
                    if (args.version) {
                        return [
                            2,
                            logger.log(version)
                        ];
                    }
                    if (args.help) {
                        return [
                            2,
                            help()
                        ];
                    }
                    entry = source ? path__default["default"].resolve(cwd, source) : "";
                    bundle = require("./lib").bundle;
                    timeStart = Date.now();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        bundle(entry, cliArgs)
                    ];
                case 2:
                    _state.sent();
                    timeEnd = Date.now();
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    if (err.name === "NOT_EXISTED") {
                        help();
                        return [
                            2,
                            exit(err)
                        ];
                    }
                    throw err;
                case 4:
                    duration = timeEnd - timeStart;
                    if (!watch) {
                        logger.log("âœ¨  Finished in " + formatDuration(duration));
                    }
                    return [
                        2
                    ];
            }
        });
    });
    return _run.apply(this, arguments);
}
function main() {
    return _main.apply(this, arguments);
}
function _main() {
    _main = _asyncToGenerator(function() {
        var params, error;
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    try {
                        params = parseCliArgs(process.argv.slice(2));
                    } catch (err) {
                        error = err;
                    }
                    if (error || !params) {
                        if (!error) help();
                        return [
                            2,
                            exit(error)
                        ];
                    }
                    return [
                        4,
                        run(params)
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    });
    return _main.apply(this, arguments);
}
main().catch(exit);
