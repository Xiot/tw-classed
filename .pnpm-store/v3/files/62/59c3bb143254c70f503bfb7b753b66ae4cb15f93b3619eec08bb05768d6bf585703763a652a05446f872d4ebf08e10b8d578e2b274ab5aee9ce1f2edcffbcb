Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');
var rollup = require('rollup');
var rollupPluginSwc3 = require('rollup-plugin-swc3');
var commonjs = require('@rollup/plugin-commonjs');
var shebang = require('rollup-plugin-preserve-shebang');
var json = require('@rollup/plugin-json');
var pluginNodeResolve = require('@rollup/plugin-node-resolve');
var module$1 = require('module');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var commonjs__default = /*#__PURE__*/_interopDefaultLegacy(commonjs);
var shebang__default = /*#__PURE__*/_interopDefaultLegacy(shebang);
var json__default = /*#__PURE__*/_interopDefaultLegacy(json);

var rootDir = process.cwd();
var config = {
    rootDir: rootDir
};

function getTypings(pkg) {
    return pkg.types || pkg.typings;
}
function getDistPath(distPath) {
    return path.resolve(config.rootDir, distPath);
}
function findExport(field) {
    if (!field) return;
    if (typeof field === "string") return field;
    var value = field["."] || field["import"] || field["module"] || field["default"];
    return findExport(value);
}
function parseExport(exportsCondition) {
    var paths = {};
    if (typeof exportsCondition === "string") {
        paths.export = exportsCondition;
    } else {
        paths.main = paths.main || exportsCondition["require"] || exportsCondition["node"] || exportsCondition["default"];
        paths.module = paths.module || exportsCondition["module"];
        paths.export = findExport(exportsCondition);
    }
    return paths;
}
function getExportPaths(pkg) {
    var pathsMap = {};
    var mainExport = {};
    if (pkg.main) {
        mainExport.main = pkg.main;
    }
    if (pkg.module) {
        mainExport.module = pkg.module;
    }
    pathsMap["."] = mainExport;
    var exportsConditions = pkg.exports;
    if (exportsConditions) {
        if (typeof exportsConditions === "string") {
            mainExport.export = exportsConditions;
        } else {
            var exportKeys = Object.keys(exportsConditions);
            if (exportKeys.some(function(key) {
                return key.startsWith(".");
            })) {
                exportKeys.forEach(function(subExport) {
                    pathsMap[subExport] = parseExport(exportsConditions[subExport]);
                });
            } else {
                Object.assign(mainExport, parseExport(exportsConditions));
            }
        }
    }
    pathsMap["."] = mainExport;
    return pathsMap;
}
function getExportDist(pkg) {
    var paths = getExportPaths(pkg)["."];
    var dist = [];
    if (paths.main) {
        dist.push({
            format: "cjs",
            file: getDistPath(paths.main)
        });
    }
    if (paths.module) {
        dist.push({
            format: "esm",
            file: getDistPath(paths.module)
        });
    }
    if (paths.export) {
        dist.push({
            format: "esm",
            file: getDistPath(paths.export)
        });
    }
    // default fallback to output `dist/index.js` in default esm format
    if (dist.length === 0) {
        dist.push({
            format: "esm",
            file: getDistPath("dist/index.js")
        });
    }
    return dist;
}
function getExportConditionDist(pkg, exportCondition) {
    // const pkgExports = pkg.exports || {}
    var dist = [];
    // "exports": "..."
    if (typeof exportCondition === "string") {
        dist.push({
            format: pkg.type === "module" ? "esm" : "cjs",
            file: getDistPath(exportCondition)
        });
    } else {
        // "./<subexport>": { }
        var subExports = exportCondition // pkgExports[subExport]
        ;
        // Ignore json exports, like "./package.json"
        // if (subExport.endsWith('.json')) return dist
        if (typeof subExports === "string") {
            dist.push({
                format: "esm",
                file: getDistPath(subExports)
            });
        } else {
            if (subExports.require) {
                dist.push({
                    format: "cjs",
                    file: getDistPath(subExports.require)
                });
            }
            if (subExports.import) {
                dist.push({
                    format: "esm",
                    file: getDistPath(subExports.import)
                });
            }
        }
    }
    return dist;
}

function exit(err) {
    logger.error(err);
    process.exit(1);
}
var formatDuration = function(duration) {
    return duration >= 1000 ? "" + duration / 1000 + "s" : "" + duration + "ms";
};
function getPackageMeta(cwd) {
    var pkgFilePath = path__default["default"].resolve(cwd, "package.json");
    var targetPackageJson = {};
    try {
        targetPackageJson = JSON.parse(fs__default["default"].readFileSync(pkgFilePath, {
            encoding: "utf-8"
        }));
    } catch (_) {}
    return targetPackageJson;
}
var logger = {
    log: function log(arg) {
        console.log(arg);
    },
    warn: function warn(arg) {
        console.log("\x1b[33m" + arg + "\x1b[0m");
    },
    error: function error(arg) {
        console.error("\x1b[31m" + arg + "\x1b[0m");
    }
};
function isTypescript(filename) {
    var ext = path__default["default"].extname(filename);
    return ext === ".ts" || ext === ".tsx";
}
var isNotNull = function(n) {
    return Boolean(n);
};

function _extends$1() {
    _extends$1 = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$1.apply(this, arguments);
}
var minifyOptions = {
    compress: true,
    format: {
        comments: "some",
        wrapFuncArgs: false,
        preserveAnnotations: true
    },
    mangle: true
};
var hasLoggedTsWarning = false;
function resolveTypescript(cwd) {
    var ts;
    var m = new module$1.Module("", undefined);
    m.paths = module$1.Module._nodeModulePaths(cwd);
    try {
        ts = m.require("typescript");
    } catch (_) {
        console.error(_);
        if (!hasLoggedTsWarning) {
            hasLoggedTsWarning = true;
            exit("Could not load TypeScript compiler. Try to install `typescript` as dev dependency");
        }
    }
    return ts;
}
function buildInputConfig(entry, pkg, options, param) {
    var tsConfigPath = param.tsConfigPath, tsCompilerOptions = param.tsCompilerOptions, dtsOnly = param.dtsOnly;
    var _external;
    var externals = [
        pkg.peerDependencies,
        pkg.dependencies,
        pkg.peerDependenciesMeta
    ].filter(function(n) {
        return Boolean(n);
    }).map(function(o) {
        return Object.keys(o);
    }).reduce(function(a, b) {
        return a.concat(b);
    }, []).concat(((_external = options.external) != null ? _external : []).concat(pkg.name ? [
        pkg.name
    ] : []));
    var useTypescript = options.useTypescript, runtime = options.runtime, jscTarget = options.target, minify = options.minify;
    var _obj;
    var plugins = (dtsOnly ? [
        shebang__default["default"](),
        useTypescript && require("rollup-plugin-dts").default({
            compilerOptions: _extends$1({}, tsCompilerOptions, {
                declaration: true,
                noEmit: false,
                noEmitOnError: true,
                emitDeclarationOnly: true,
                checkJs: false,
                declarationMap: false,
                skipLibCheck: true,
                preserveSymlinks: false,
                target: "esnext",
                module: "esnext",
                incremental: false,
                jsx: (tsCompilerOptions == null ? void 0 : tsCompilerOptions.jsx) || "react"
            })
        })
    ] : [
        pluginNodeResolve.nodeResolve({
            preferBuiltins: runtime === "node",
            extensions: [
                ".mjs",
                ".js",
                ".json",
                ".node",
                ".jsx"
            ]
        }),
        commonjs__default["default"]({
            include: /node_modules\//
        }),
        json__default["default"](),
        shebang__default["default"](),
        rollupPluginSwc3.swc({
            include: /\.(m|c)?[jt]sx?$/,
            exclude: "node_modules",
            tsconfig: tsConfigPath,
            jsc: _extends$1({
                target: jscTarget,
                loose: true,
                externalHelpers: false,
                parser: (_obj = {
                    syntax: useTypescript ? "typescript" : "ecmascript"
                }, _obj[useTypescript ? "tsx" : "jsx"] = true, _obj.privateMethod = true, _obj.classPrivateProperty = true, _obj.exportDefaultFrom = true, _obj)
            }, minify && {
                minify: _extends$1({}, minifyOptions, {
                    sourceMap: options.sourcemap
                })
            }),
            sourceMaps: options.sourcemap,
            inlineSourcesContent: false
        })
    ]).filter(isNotNull);
    return {
        input: entry,
        external: function external(id) {
            return externals.some(function(name) {
                return id === name || id.startsWith(name + "/");
            });
        },
        plugins: plugins,
        treeshake: {
            propertyReadSideEffects: false
        },
        onwarn: function onwarn(warning, warn) {
            var code = warning.code || "";
            // Some may not have types, like CLI binary
            if (dtsOnly && code === "EMPTY_BUNDLE") return;
            if ([
                "MIXED_EXPORTS",
                "PREFER_NAMED_EXPORTS",
                "UNRESOLVED_IMPORT",
                "THIS_IS_UNDEFINED"
            ].includes(code)) return;
            // If the circular dependency warning is from node_modules, ignore it
            if (code === "CIRCULAR_DEPENDENCY" && /Circular dependency: node_modules/.test(warning.message)) {
                return;
            }
            warn(warning);
        }
    };
}
function buildOutputConfigs(options, pkg, param) {
    var tsCompilerOptions = param.tsCompilerOptions, dtsOnly = param.dtsOnly;
    var format = options.format, exportCondition = options.exportCondition;
    var exportPaths = getExportPaths(pkg);
    // respect if tsconfig.json has `esModuleInterop` config;
    // add ESModule mark if cjs and ESModule are both generated;
    // TODO: support `import` in exportCondition
    var useEsModuleMark = Boolean(tsCompilerOptions.esModuleInterop || exportPaths.main && exportPaths.module);
    var typings = getTypings(pkg);
    var file = options.file && path.resolve(config.rootDir, options.file);
    var dtsDir = typings ? path.dirname(path.resolve(config.rootDir, typings)) : path.resolve(config.rootDir, "dist");
    // file base name without extension
    var name = file ? file.replace(new RegExp("" + path.extname(file) + "$"), "") : undefined;
    var dtsFile = file ? name + ".d.ts" : (exportCondition == null ? void 0 : exportCondition.name) ? path.resolve(dtsDir, (exportCondition.name === "." ? "index" : exportCondition.name) + ".d.ts") : typings && path.resolve(config.rootDir, typings);
    // If there's dts file, use `output.file`
    var dtsPathConfig = dtsFile ? {
        file: dtsFile
    } : {
        dir: dtsDir
    };
    return _extends$1({
        name: pkg.name || name
    }, dtsOnly ? dtsPathConfig : {
        file: file
    }, {
        format: format,
        exports: "named",
        esModule: useEsModuleMark,
        freeze: false,
        strict: false,
        sourcemap: options.sourcemap
    });
}
function buildConfig(entry, pkg, cliArgs, dtsOnly) {
    var ref;
    var file = cliArgs.file;
    var useTypescript = isTypescript(entry);
    var options = _extends$1({}, cliArgs, {
        useTypescript: useTypescript
    });
    var tsCompilerOptions = {};
    var tsConfigPath;
    if (useTypescript) {
        var ts = resolveTypescript(config.rootDir);
        tsConfigPath = path.resolve(config.rootDir, "tsconfig.json");
        if (fs__default["default"].existsSync(tsConfigPath)) {
            var tsconfigJSON = ts.readConfigFile(tsConfigPath, ts.sys.readFile).config;
            tsCompilerOptions = ts.parseJsonConfigFileContent(tsconfigJSON, ts.sys, "./").options;
        } else {
            tsConfigPath = undefined;
            exit("tsconfig.json is missing in your project directory");
        }
    }
    var typescriptOptions = {
        dtsOnly: dtsOnly,
        tsConfigPath: tsConfigPath,
        tsCompilerOptions: tsCompilerOptions
    };
    var inputOptions = buildInputConfig(entry, pkg, options, typescriptOptions);
    var outputExports = options.exportCondition ? getExportConditionDist(pkg, options.exportCondition.export) : getExportDist(pkg);
    var outputConfigs = [];
    // Generate dts job - single config
    if (dtsOnly) {
        outputConfigs = [
            buildOutputConfigs(_extends$1({}, cliArgs, {
                format: "es",
                useTypescript: useTypescript
            }), pkg, typescriptOptions)
        ];
    } else {
        // multi outputs with specified format
        outputConfigs = outputExports.map(function(exportDist) {
            return buildOutputConfigs(_extends$1({}, cliArgs, {
                file: exportDist.file,
                format: exportDist.format,
                useTypescript: useTypescript
            }), pkg, typescriptOptions);
        });
        // CLI output option is always prioritized
        if (file) {
            var ref1;
            var fallbackFormat = (ref1 = outputExports[0]) == null ? void 0 : ref1.format;
            outputConfigs = [
                buildOutputConfigs(_extends$1({}, cliArgs, {
                    file: file,
                    format: cliArgs.format || fallbackFormat,
                    useTypescript: useTypescript
                }), pkg, typescriptOptions)
            ];
        }
    }
    return {
        input: inputOptions,
        output: outputConfigs,
        exportName: ((ref = options.exportCondition) == null ? void 0 : ref.name) || ".",
        dtsOnly: dtsOnly
    };
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var __generator = undefined && undefined.__generator || function(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
function logBuild(exportPath, dtsOnly, duration) {
    logger.log(" ✓  " + (dtsOnly ? "Typed" : "Built") + " " + exportPath + " " + formatDuration(duration));
}
function assignDefault(options, name, defaultValue) {
    if (!(name in options) || options[name] == null) {
        options[name] = defaultValue;
    }
}
// Map '.' -> './index.[ext]'
// Map './lite' -> './lite.[ext]'
function getSourcePathFromExportPath(cwd, exportPath) {
    var exts = [
        "js",
        "cjs",
        "mjs",
        "jsx",
        "ts",
        "tsx"
    ];
    for(var _iterator = _createForOfIteratorHelperLoose(exts), _step; !(_step = _iterator()).done;){
        var ext = _step.value;
        // ignore package.json
        if (exportPath.endsWith("package.json")) return;
        if (exportPath === ".") exportPath = "./index";
        var filename = path.resolve(cwd, exportPath + "." + ext);
        if (fs__default["default"].existsSync(filename)) {
            return filename;
        }
    }
    return;
}
function bundle(entryPath) {
    return _bundle.apply(this, arguments);
}
function _bundle() {
    _bundle = _asyncToGenerator(function(entryPath, _param) {
        var cwd, options, pkg, packageExports, isSingleEntry, hasMultiEntries, bundleOrWatch, hasSpecifiedEntryFile, err, hasTypings, assetsJobs, typesJobs, rollupConfig;
        function buildEntryConfig(packageExports, dtsOnly) {
            var configs = Object.keys(packageExports).map(function(entryExport) {
                var source = getSourcePathFromExportPath(config.rootDir, entryExport);
                if (!source) return undefined;
                if (dtsOnly && !isTypescript(source)) return;
                options.exportCondition = {
                    source: source,
                    name: entryExport,
                    export: packageExports[entryExport]
                };
                var entry = path.resolve(cwd, source);
                var rollupConfig = buildConfig(entry, pkg, options, dtsOnly);
                return rollupConfig;
            }).filter(function(v) {
                return !!v;
            });
            return configs;
        }
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (_param === void 0) _param = {};
                    cwd = _param.cwd, options = _objectWithoutPropertiesLoose(_param, [
                        "cwd"
                    ]);
                    config.rootDir = path.resolve(process.cwd(), cwd || "");
                    assignDefault(options, "format", "es");
                    assignDefault(options, "minify", false);
                    assignDefault(options, "target", "es5");
                    if (options.dts === undefined && isTypescript(entryPath)) {
                        options.dts = true;
                    }
                    pkg = getPackageMeta(config.rootDir);
                    packageExports = pkg.exports || {};
                    isSingleEntry = typeof packageExports === "string";
                    hasMultiEntries = packageExports && !isSingleEntry && Object.keys(packageExports).length > 0;
                    if (isSingleEntry) {
                        entryPath = getSourcePathFromExportPath(config.rootDir, ".");
                    }
                    bundleOrWatch = function(rollupConfig) {
                        var input = rollupConfig.input, exportName = rollupConfig.exportName;
                        var exportPath = getExportPath(pkg, exportName);
                        // Log original entry file relative path
                        var source = typeof input.input === "string" ? path.relative(config.rootDir, input.input) : exportPath;
                        var buildMetadata = {
                            source: source
                        };
                        if (options.watch) {
                            return Promise.resolve(runWatch(rollupConfig, buildMetadata));
                        }
                        return runBundle(rollupConfig, buildMetadata);
                    };
                    if (!!fs__default["default"].existsSync(entryPath)) return [
                        3,
                        2
                    ];
                    hasSpecifiedEntryFile = entryPath === "" ? false : fs__default["default"].statSync(entryPath).isFile();
                    if (!hasSpecifiedEntryFile && !hasMultiEntries) {
                        err = new Error("Entry file `" + entryPath + "` is not existed");
                        err.name = "NOT_EXISTED";
                        return [
                            2,
                            Promise.reject(err)
                        ];
                    }
                    hasTypings = !!getTypings(pkg) || typeof packageExports === "object" && Array.from(Object.values(packageExports || {})).some(function(condition) {
                        return condition.hasOwnProperty("types");
                    });
                    // If there's no entry file specified, should enable dts bundling based on package.json exports info
                    if (!hasSpecifiedEntryFile && hasTypings) {
                        options.dts = hasTypings;
                    }
                    if (!hasMultiEntries) return [
                        3,
                        2
                    ];
                    assetsJobs = buildEntryConfig(packageExports, false).map(function(rollupConfig) {
                        return bundleOrWatch(rollupConfig);
                    });
                    typesJobs = options.dts ? buildEntryConfig(packageExports, true).map(function(rollupConfig) {
                        return bundleOrWatch(rollupConfig);
                    }) : [];
                    return [
                        4,
                        Promise.all(assetsJobs.concat(typesJobs))
                    ];
                case 1:
                    return [
                        2,
                        _state.sent()
                    ];
                case 2:
                    if (!(isTypescript(entryPath) && options.dts)) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        bundleOrWatch(buildConfig(entryPath, pkg, options, true))
                    ];
                case 3:
                    _state.sent();
                    _state.label = 4;
                case 4:
                    rollupConfig = buildConfig(entryPath, pkg, options, false);
                    return [
                        2,
                        bundleOrWatch(rollupConfig)
                    ];
            }
        });
    });
    return _bundle.apply(this, arguments);
}
// . -> pkg name
// ./lite -> <pkg name>/lite
function getExportPath(pkg, exportName) {
    var name = pkg.name || path.basename(config.rootDir);
    if (exportName === "." || !exportName) return name;
    return path.join(name, exportName);
}
function runWatch(param, metadata) {
    var input = param.input, output = param.output, dtsOnly = param.dtsOnly;
    var watchOptions = [
        _extends({}, input, {
            output: output,
            watch: {
                exclude: [
                    "node_modules/**"
                ]
            }
        })
    ];
    var watcher = rollup.watch(watchOptions);
    var startTime = Date.now();
    watcher.on("event", function(event) {
        switch(event.code){
            case "ERROR":
                {
                    return onError(event.error);
                }
            case "START":
                {
                    startTime = Date.now();
                    logger.log("Start building " + metadata.source + " ...");
                    break;
                }
            case "END":
                {
                    var duration = Date.now() - startTime;
                    logBuild(metadata.source, dtsOnly, duration);
                    break;
                }
            default:
                return;
        }
    });
    return watcher;
}
function runBundle(param, jobOptions) {
    var input = param.input, output = param.output, dtsOnly = param.dtsOnly;
    var startTime = Date.now();
    return rollup.rollup(input).then(function(bundle) {
        var writeJobs = output.map(function(options) {
            return bundle.write(options);
        });
        return Promise.all(writeJobs);
    }, onError).then(function() {
        var duration = Date.now() - startTime;
        logBuild(jobOptions.source, dtsOnly, duration);
    });
}
function onError(error) {
    if (!error) return;
    // logging source code in format
    if (error.frame) {
        process.stderr.write(error.frame + "\n");
    }
    // filter out the rollup plugin error information such as loc/frame/code...
    var err = new Error(error.message);
    err.stack = error.stack;
    throw err;
}

exports.bundle = bundle;
